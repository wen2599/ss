File: backend/ai_helper.php
<?php
// File: ai_helper.php

// 【新增】引入邮件解析器
require_once __DIR__ . '/helpers/mail_parser.php';

/**
 * 分析邮件内容并提取下注信息。
 * @param string $emailContent 邮件原文
 * @return array
 */
function analyzeBetSlipWithAI(string $emailContent): array {
    // 【核心修改】先解析出干净的邮件正文
    $cleanBody = parse_email_body($emailContent);

    // 如果解析失败，可以直接返回错误
    if ($cleanBody === '无法解析邮件正文') {
        return ['success' => false, 'message' => 'Failed to parse email body.'];
    }

    // 将清洗后的正文交给 AI
    return analyzeWithCloudflareAI($cleanBody);
}

/**
 * 使用 Cloudflare AI 进行分析。
 * @param string $text 清洗后的正文文本
 * @return array
 */
function analyzeWithCloudflareAI(string $text): array {
    // ... 此函数剩余部分代码保持不变 ...
    $accountId = config('CLOUDFLARE_ACCOUNT_ID');
    // ...
    $prompt = "你是一个专业的六合彩下注单识别助手...邮件原文如下：\n\n---\n{$text}\n---";
    // ...

    // --- 为了完整性，这里是剩余部分的代码 ---
    $apiToken = config('CLOUDFLARE_API_TOKEN');
    if (!$accountId || !$apiToken) return ['success' => false, 'message' => 'Cloudflare AI credentials not configured.'];
    $model = '@cf/meta/llama-3-8b-instruct';
    $url = "https://api.cloudflare.com/client/v4/accounts/{$accountId}/ai/run/{$model}";
    $payload = [
        'messages' => [
            ['role' => 'system', 'content' => '你是一个只输出严格JSON格式的助手。'],
            ['role' => 'user', 'content' => $prompt]
        ]
    ];
    $headers = [ 'Authorization: Bearer ' . $apiToken, 'Content-Type: application/json' ];
    $ch = curl_init($url);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_POST, true);
    curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($payload));
    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
    curl_setopt($ch, CURLOPT_TIMEOUT, 60);
    $responseBody = curl_exec($ch);
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    curl_close($ch);
    if ($httpCode !== 200) return ['success' => false, 'message' => "Cloudflare AI API Error (HTTP {$httpCode}): " . $responseBody];
    $responseData = json_decode($responseBody, true);
    $ai_response_text = $responseData['result']['response'] ?? null;
    if (!$ai_response_text) return ['success' => false, 'message' => 'Invalid response structure from Cloudflare AI.'];
    preg_match('/\{[\s\S]*\}/', $ai_response_text, $matches);
    if (empty($matches)) return ['success' => false, 'message' => 'AI did not return a valid JSON object.', 'raw_response' => $ai_response_text];
    $bet_data = json_decode($matches[0], true);
    if (json_last_error() !== JSON_ERROR_NONE) return ['success' => false, 'message' => 'Failed to decode JSON from AI response.', 'raw_json' => $matches[0]];
    return ['success' => true, 'data' => $bet_data, 'model' => $model];
}

---
File: backend/api_header.php
<?php
// File: backend/api_header.php

if (defined('API_HEADER_LOADED')) return;
define('API_HEADER_LOADED', true);

// 使用 config() 函数，并提供一个安全的备用值（尽管我们期望它能读到正确的URL）
$frontend_url = config('FRONTEND_URL');

// 如果 frontend_url 为空或未设置，则不发送任何 CORS 头，以便在浏览器中看到更明确的错误
if ($frontend_url) {
    header("Access-Control-Allow-Origin: " . $frontend_url);
} else {
    // 故意不设置，这样浏览器会报一个关于缺少头的错误，而不是关于 '*' 的错误
    // 这能帮助我们确认问题就是 FRONTEND_URL 没读到
}

header('Access-Control-Allow-Credentials: true');
header('Access-Control-Allow-Methods: GET, POST, OPTIONS, DELETE, PUT');
header('Access-Control-Allow-Headers: Content-Type, Authorization, X-Requested-With');

if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(204);
    exit;
}

header('Content-Type: application/json');

if (session_status() === PHP_SESSION_NONE) {
    session_set_cookie_params([
        'lifetime' => 86400, 'path' => '/',
        'domain' => '', 'secure' => true,
        'httponly' => true, 'samesite' => 'None'
    ]);
    session_start();
}

---
File: backend/config.php
<?php
// File: backend/config.php (Final Debugging Version for FRONTEND_URL)

// 定义一个调试日志文件路径
define('CONFIG_DEBUG_LOG', __DIR__ . '/config_debug.log');

// 在脚本执行时，如果日志已存在，则不清空，以便我们追加日志
// unlink(CONFIG_DEBUG_LOG);

function _log_config_debug($message) {
    error_log(date('[Y-m-d H:i:s] ') . $message . "\n", 3, CONFIG_DEBUG_LOG);
}

// 记录哪个文件正在加载 config.php
$caller = debug_backtrace()[0]['file'];
_log_config_debug("--- config.php loaded by: {$caller} ---");

if (!function_exists('config')) {
    function config(string $key, $default = null) {
        static $config = null;

        if ($config === null) {
            _log_config_debug("Static \$config is null. Initializing...");
            $config = [];
            $envPath = __DIR__ . '/.env';

            if (file_exists($envPath) && is_readable($envPath)) {
                $lines = file($envPath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
                if ($lines) {
                    foreach ($lines as $line) {
                        if (strpos(trim($line), ';') === 0) continue;
                        if (strpos($line, ';') !== false) {
                            $line = substr($line, 0, strpos($line, ';'));
                        }
                        if (strpos($line, '=') !== false) {
                            list($name, $value) = explode('=', $line, 2);
                            $name = trim($name);
                            $value = trim(trim($value), "\"'");
                            $config[$name] = $value;
                            if ($name === 'FRONTEND_URL') {
                                _log_config_debug("SUCCESS: Found and loaded [FRONTEND_URL] = [{$value}]");
                            }
                        }
                    }
                }
            } else {
                 _log_config_debug("FATAL: .env file not found or not readable.");
            }
        }

        $returnValue = $config[$key] ?? $default;
        _log_config_debug("config('{$key}') requested, returning: " . ($returnValue ?? 'NULL'));
        return $returnValue;
    }
}

// ... Error Handling ...
ini_set('display_errors', '0');
ini_set('log_errors', '1');
ini_set('error_log', __DIR__ . '/debug.log');
error_reporting(E_ALL);

---
File: backend/database_schema.sql
CREATE TABLE IF NOT EXISTS `users` (
  `id` INT(11) NOT NULL AUTO_INCREMENT,
  `email` VARCHAR(255) NOT NULL,
  `password_hash` VARCHAR(255) NOT NULL,
  `status` ENUM('active', 'banned') NOT NULL DEFAULT 'active',
  `created_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `email` (`email`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE IF NOT EXISTS `raw_emails` (
  `id` INT AUTO_INCREMENT PRIMARY KEY,
  `user_id` INT NOT NULL,
  `content` MEDIUMTEXT NOT NULL,
  `status` ENUM('pending', 'processed', 'failed') NOT NULL DEFAULT 'pending',
  `received_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE IF NOT EXISTS `parsed_bets` (
  `id` INT AUTO_INCREMENT PRIMARY KEY,
  `email_id` INT NOT NULL,
  `bet_data_json` JSON NOT NULL,
  `ai_model_used` VARCHAR(50),
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (`email_id`) REFERENCES `raw_emails`(`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE IF NOT EXISTS `lottery_results` (
  `id` INT AUTO_INCREMENT PRIMARY KEY,
  `lottery_type` VARCHAR(100) NOT NULL,
  `issue_number` VARCHAR(255) NOT NULL,
  `winning_numbers` JSON NOT NULL,
  `zodiac_signs` JSON NOT NULL,
  `colors` JSON NOT NULL,
  `drawing_date` DATE,
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY `type_issue` (`lottery_type`, `issue_number`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE IF NOT EXISTS `settlements` (
  `id` INT AUTO_INCREMENT PRIMARY KEY,
  `bet_id` INT NOT NULL,
  `result_data_json` JSON NOT NULL,
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (`bet_id`) REFERENCES `parsed_bets`(`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

---
File: backend/db_operations.php
<?php
// File: backend/db_operations.php (Final Standardized Version)

if (defined('DB_OPERATIONS_LOADED')) return;
define('DB_OPERATIONS_LOADED', true);

function get_db_connection() {
    static $pdo = null;
    if ($pdo === null) {
        // 【关键修改】确保我们读取的是标准化的变量名
        $dsn = sprintf("mysql:host=%s;port=%s;dbname=%s;charset=utf8mb4",
            config('DB_HOST'),
            config('DB_PORT'),
            config('DB_DATABASE') // 读取 DB_DATABASE
        );

        $options = [
            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
            PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC
        ];

        // 读取 DB_USERNAME 和 DB_PASSWORD
        $pdo = new PDO($dsn, config('DB_USERNAME'), config('DB_PASSWORD'), $options);
    }
    return $pdo;
}

---
File: backend/index.php
<?php
// File: backend/index.php (Final Version)

/**
 * Main API Entry Point.
 * This script is responsible for loading core dependencies and routing
 * requests to the appropriate endpoint handlers.
 */

// --- 1. Load ALL core dependencies in one place, in the correct order ---

// config.php defines the config() helper function and sets up error logging.
require_once __DIR__ . '/config.php';

// db_operations.php defines get_db_connection() and uses the config() helper.
require_once __DIR__ . '/db_operations.php';

// api_header.php handles CORS headers, session start, and content type. It also uses config().
require_once __DIR__ . '/api_header.php';


// --- 2. Get endpoint parameter from the URL ---
$endpoint = $_GET['endpoint'] ?? null;

if ($endpoint === null) {
    http_response_code(400); // Bad Request
    echo json_encode(['status' => 'error', 'message' => 'Missing endpoint parameter.']);
    exit();
}


// --- 3. Define the routing map ---
// This array maps the 'endpoint' string to the physical PHP file.
$routes = [
    // Authentication endpoints
    'register'              => 'auth/register.php',
    'login'                 => 'auth/login.php',
    'logout'                => 'auth/logout.php',
    'check_session'         => 'auth/check_session.php',

    // Email related endpoints
    'get_emails'            => 'auth/get_emails.php',
    'get_email_details'     => 'auth/get_email_details.php',
    'update_bet_batch'      => 'auth/update_bet_batch.php',

    // Lottery related endpoints
    'get_lottery_results'       => 'lottery/get_results.php',
    'get_lottery_result_by_issue' => 'lottery/get_result_by_issue.php',

    // Settlement related endpoints (Placeholder for future)
    // 'run_settlement'      => 'settlement/run.php',
    // 'get_settlements'     => 'settlement/get_list.php',
];


// --- 4. Route the request ---
if (isset($routes[$endpoint])) {
    // If the endpoint is valid, include the corresponding handler file.
    // The handler file will then take over and produce the output.
    require_once __DIR__ . '/' . $routes[$endpoint];
} else {
    // If the endpoint is not found in our map, return a 404 error.
    http_response_code(404); // Not Found
    echo json_encode(['status' => 'error', 'message' => 'Endpoint not found.']);
}

---
File: backend/initialize_database.php
<?php
// File: backend/initialize_database.php (Final Corrected Version)

// 开启命令行错误显示，以便看到任何问题
ini_set('display_errors', 1);
error_reporting(E_ALL);

echo "--- Database Initialization Script ---\n\n";
echo "Step 1: Loading core files...\n";

// 【关键修复】确保所有必要的文件都被加载
// 首先加载配置文件，因为它定义了 config() 函数
require_once __DIR__ . '/config.php';
// 然后加载数据库操作文件，因为它定义了 get_db_connection() 函数
require_once __DIR__ . '/db_operations.php';

echo "  [SUCCESS] All core files loaded.\n\n";

try {
    echo "Step 2: Getting database connection...\n";
    // 现在 get_db_connection() 函数肯定是已定义的
    $pdo = get_db_connection();
    echo "  [SUCCESS] Database connection established.\n\n";

    echo "Step 3: Reading schema file...\n";
    $sql_file_path = __DIR__ . '/database_schema.sql';
    if (!file_exists($sql_file_path)) {
        throw new Exception("File not found: {$sql_file_path}");
    }
    $sql = file_get_contents($sql_file_path);
    echo "  [SUCCESS] SQL schema file read.\n\n";

    echo "Step 4: Executing SQL to create tables...\n";
    $pdo->exec($sql);
    echo "  [SUCCESS] All tables created or already exist.\n\n";

} catch (Throwable $e) { // 捕获所有类型的错误
    echo "\n[FAILURE] An error occurred during initialization:\n";
    echo "--------------------------------------------------\n";
    echo "Error Type: " . get_class($e) . "\n";
    echo "Message: " . $e->getMessage() . "\n";
    echo "File: " . $e->getFile() . "\n";
    echo "Line: " . $e->getLine() . "\n";
    echo "--------------------------------------------------\n";
    exit(1);
}

echo "--- Initialization Complete! ---\n";
?>

---
File: backend/mail_receiver_light.php
<?php
// File: mail_receiver_light.php (完全简化版 - 无频率检查)

// --- 独立的日志系统 ---
define('MAIL_LOG_FILE', __DIR__ . '/mail_debug.log');
function log_mail_debug($message) {
    error_log(date('[Y-m-d H:i:s] ') . $message . "\n", 3, MAIL_LOG_FILE);
}

log_mail_debug("=== 邮件接收器开始 (简化版) ===");

try {
    // --- 1. 加载所有核心依赖 ---
    require_once __DIR__ . '/config.php';
    require_once __DIR__ . '/ai_helper.php';
    log_mail_debug("依赖加载完成");

    // --- 2. 安全验证 (Bearer Token) ---
    $secret = config('EMAIL_WORKER_SECRET');
    if (!$secret) {
        throw new Exception("EMAIL_WORKER_SECRET 未配置");
    }

    $auth_header = $_SERVER['HTTP_AUTHORIZATION'] ?? '';
    $token = str_replace('Bearer ', '', $auth_header);

    if (!hash_equals($secret, $token)) {
        log_mail_debug("禁止访问: 无效的 token");
        http_response_code(403);
        echo json_encode(['status' => 'error', 'message' => '禁止访问']);
        exit;
    }
    log_mail_debug("安全检查通过");

    // --- 3. 获取并验证输入 (JSON格式) ---
    $json_input = file_get_contents('php://input');
    if (empty($json_input)) {
        throw new Exception("空的 JSON 输入");
    }

    $input = json_decode($json_input, true);
    if ($input === null) {
        throw new Exception("无效的 JSON 数据");
    }

    $sender_email = $input['sender'] ?? null;
    $raw_content = $input['raw_content'] ?? null;

    if (empty($sender_email) || empty($raw_content)) {
        throw new Exception("缺少 'sender' 或 'raw_content' 字段");
    }
    log_mail_debug("收到来自: " . $sender_email . " 的邮件");

    // --- 4. 连接数据库 ---
    $dsn = sprintf("mysql:host=%s;port=%s;dbname=%s;charset=utf8mb4",
        config('DB_HOST'), config('DB_PORT'), config('DB_DATABASE')
    );
    $options = [ PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION ];
    $pdo = new PDO($dsn, config('DB_USERNAME'), config('DB_PASSWORD'), $options);
    log_mail_debug("数据库连接成功");

    // --- 5. 查找用户 ---
    $stmt_find = $pdo->prepare("SELECT id FROM users WHERE email = ? AND status = 'active'");
    $stmt_find->execute([$sender_email]);
    $user_id = $stmt_find->fetchColumn();

    if ($user_id) {
        log_mail_debug("找到用户 ID: " . $user_id);

        // --- 步骤 A: 存入原始邮件 ---
        $stmt_insert_raw = $pdo->prepare("INSERT INTO raw_emails (user_id, content, status) VALUES (?, ?, 'pending')");
        $stmt_insert_raw->execute([$user_id, $raw_content]);
        $email_id = $pdo->lastInsertId();
        log_mail_debug("邮件存入 raw_emails，ID: " . $email_id);

        // --- 步骤 B: 调用 AI 分析 ---
        log_mail_debug("调用 AI 分析邮件内容...");
        $ai_result = analyzeBetSlipWithAI($raw_content);

        if ($ai_result['success']) {
            // AI 分析成功
            $model_used = $ai_result['model'] ?? 'unknown_model';
            log_mail_debug("AI 分析成功。模型: " . $model_used);
            $bet_data_json = json_encode($ai_result['data']);

            // 存入 parsed_bets 表
            $stmt_insert_parsed = $pdo->prepare("INSERT INTO parsed_bets (email_id, bet_data_json, ai_model_used) VALUES (?, ?, ?)");
            $stmt_insert_parsed->execute([$email_id, $bet_data_json, $model_used]);

            // 更新 raw_emails 状态为 processed
            $stmt_update_status = $pdo->prepare("UPDATE raw_emails SET status = 'processed' WHERE id = ?");
            $stmt_update_status->execute([$email_id]);
            log_mail_debug("解析数据已存储，状态更新为 processed");

            http_response_code(200);
            echo json_encode([
                'status' => 'success',
                'message' => '邮件处理完成',
                'ai_status' => 'success',
                'email_id' => $email_id,
                'model_used' => $model_used
            ]);
        } else {
            // AI 分析失败
            $error_message = $ai_result['message'] ?? '未知 AI 错误';
            log_mail_debug("AI 分析失败。原因: " . $error_message);

            // 更新 raw_emails 状态为 failed
            $stmt_update_status = $pdo->prepare("UPDATE raw_emails SET status = 'failed' WHERE id = ?");
            $stmt_update_status->execute([$email_id]);

            http_response_code(200);
            echo json_encode([
                'status' => 'success',
                'message' => '邮件已保存但 AI 分析失败',
                'ai_status' => 'failed',
                'email_id' => $email_id,
                'ai_error' => $error_message
            ]);
        }

    } else {
        log_mail_debug("用户 '{$sender_email}' 未找到或未激活。忽略邮件");
        http_response_code(200);
        echo json_encode(['status' => 'success', 'message' => '用户未处理']);
    }

} catch (Throwable $e) {
    log_mail_debug("--- 严重错误 ---");
    log_mail_debug("错误信息: " . $e->getMessage());
    log_mail_debug("文件: " . $e->getFile() . " 第 " . $e->getLine() . " 行");
    http_response_code(500);
    echo json_encode(['status' => 'error', 'message' => '内部服务器错误']);
}

log_mail_debug("=== 邮件接收器完成 ===\n");
?>

---
File: backend/setup_bot.php
<?php
// File: backend/setup_bot.php (Final version that reads from .env)

// --- 独立的 .env 加载器 (和 receiver.php 中那个一样) ---
function load_env_for_setup() {
    $envPath = __DIR__ . '/.env';
    if (!file_exists($envPath)) {
        die("Error: .env file not found in " . __DIR__);
    }
    $lines = file($envPath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
    if (!$lines) {
        die("Error: Could not read .env file.");
    }
    foreach ($lines as $line) {
        if (strpos(trim($line), ';') === 0) continue;
        if (strpos($line, ';') !== false) $line = substr($line, 0, strpos($line, ';'));
        if (strpos($line, '=') !== false) {
            list($name, $value) = explode('=', $line, 2);
            // 这里我们只需要 getenv 能工作就行
            putenv(trim($name) . "=" . trim(trim($value), "\"'"));
        }
    }
}

// 加载配置
load_env_for_setup();

$bot_token = getenv('TELEGRAM_BOT_TOKEN');
$webhook_secret = getenv('TELEGRAM_WEBHOOK_SECRET'); // 从 .env 读取新密钥

if (!$bot_token || !$webhook_secret) {
    die("Error: TELEGRAM_BOT_TOKEN or TELEGRAM_WEBHOOK_SECRET not found in .env file.");
}

// 直接指向我们轻量级的 receiver.php
$webhook_url = "https://wenge.cloudns.ch/telegram/receiver.php?secret=" . urlencode($webhook_secret);

$api_url = "https://api.telegram.org/bot{$bot_token}/setWebhook?url=" . urlencode($webhook_url);

// 调用 API 并显示结果
$response = file_get_contents($api_url);
header('Content-Type: application/json');
echo $response;
?>

---
File: backend/auth/check_session.php
<?php
// File: backend/auth/check_session.php

// api_header.php 已经启动了 session

// 检查 session 中是否存在 user_id
if (isset($_SESSION['user_id']) && !empty($_SESSION['user_id'])) {
    // 用户已登录，返回用户信息
    http_response_code(200);
    echo json_encode([
        'status' => 'success',
        'isAuthenticated' => true,
        'user' => [
            'id' => $_SESSION['user_id'],
            'email' => $_SESSION['user_email'] ?? 'N/A' // 提供一个默认值以防万一
        ]
    ]);
} else {
    // 用户未登录
    http_response_code(200); // 即使未登录，请求本身也是成功的
    echo json_encode([
        'status' => 'success',
        'isAuthenticated' => false,
        'user' => null
    ]);
}
?>

---
File: backend/auth/get_email_content.php
<?php
// File: backend/auth/get_email_content.php (with Server-Side Parsing)

// 核心依赖由 index.php 加载

// 【新增】加载邮件解析器帮助文件
// 确保这个路径是正确的。如果你的 helpers 目录在 backend/ 根目录下。
require_once __DIR__ . '/../helpers/mail_parser.php';

// 1. 身份验证检查
if (!isset($_SESSION['user_id'])) {
    http_response_code(401);
    echo json_encode(['status' => 'error', 'message' => 'Unauthorized']);
    exit;
}

$user_id = $_SESSION['user_id'];
$email_id = $_GET['id'] ?? null;

if (empty($email_id)) {
    http_response_code(400);
    echo json_encode(['status' => 'error', 'message' => 'Email ID is required.']);
    exit;
}

try {
    $pdo = get_db_connection();

    // 2. 查询特定邮件的原始内容
    $stmt = $pdo->prepare(
        "SELECT id, content
         FROM raw_emails
         WHERE id = ? AND user_id = ?"
    );

    $stmt->bindParam(1, $email_id, PDO::PARAM_INT);
    $stmt->bindParam(2, $user_id, PDO::PARAM_INT);
    $stmt->execute();

    $email = $stmt->fetch(PDO::FETCH_ASSOC);

    if ($email) {
        // --- 【核心修改】在这里进行邮件解析 ---
        $raw_content = $email['content'];
        $clean_body = parse_email_body($raw_content);

        // 创建一个新的数组，只包含我们想返回给前端的数据
        $response_data = [
            'id' => $email['id'],
            'content' => $clean_body // 返回解析后的干净正文
        ];

        // 3. 返回包含干净正文的成功响应
        http_response_code(200);
        echo json_encode(['status' => 'success', 'data' => $response_data]);

    } else {
        http_response_code(404);
        echo json_encode(['status' => 'error', 'message' => 'Email not found or access denied.']);
    }

} catch (PDOException $e) {
    error_log("Error fetching email content for user {$user_id}, email {$email_id}: " . $e->getMessage());
    http_response_code(500);
    echo json_encode(['status' => 'error', 'message' => 'Database error.']);
} catch (Throwable $e) {
    // 捕获可能在 parse_email_body 中发生的错误
    error_log("Error parsing email content for email {$email_id}: " . $e->getMessage());
    http_response_code(500);
    echo json_encode(['status' => 'error', 'message' => 'Failed to parse email content on server.']);
}
?>

---
File: backend/auth/get_email_details.php
<?php
// File: backend/auth/get_email_details.php (Upgraded with Auto Lottery Matching)

if (!isset($_SESSION['user_id'])) {
    http_response_code(401);
    echo json_encode(['status' => 'error', 'message' => 'Unauthorized']);
    exit;
}

$user_id = $_SESSION['user_id'];
$email_id = $_GET['id'] ?? null;

if (empty($email_id)) {
    http_response_code(400);
    echo json_encode(['status' => 'error', 'message' => 'Email ID is required.']);
    exit;
}

try {
    $pdo = get_db_connection();

    // --- 1. 获取原始邮件内容 (清洗后) ---
    $stmt_email = $pdo->prepare("SELECT content FROM raw_emails WHERE id = ? AND user_id = ?");
    $stmt_email->execute([$email_id, $user_id]);
    $raw_content = $stmt_email->fetchColumn();

    if ($raw_content === false) {
        http_response_code(404);
        echo json_encode(['status' => 'error', 'message' => 'Email not found or access denied.']);
        exit;
    }

    require_once __DIR__ . '/../helpers/mail_parser.php';
    $clean_content = parse_email_body($raw_content);

    // --- 2. 获取所有关联的下注批次 ---
    $stmt_bets = $pdo->prepare("SELECT id, bet_data_json FROM parsed_bets WHERE email_id = ? ORDER BY id ASC");
    $stmt_bets->execute([$email_id]);
    $bet_batches_raw = $stmt_bets->fetchAll(PDO::FETCH_ASSOC);

    $bet_batches = array_map(function($batch) {
        return [
            'batch_id' => $batch['id'],
            'data' => json_decode($batch['bet_data_json'], true)
        ];
    }, $bet_batches_raw);

    // --- 3. 【核心新增】获取所有彩种的最新开奖结果 ---
    $sql_latest_results = "
        SELECT r1.*
        FROM lottery_results r1
        JOIN (
            SELECT lottery_type, MAX(id) AS max_id
            FROM lottery_results
            GROUP BY lottery_type
        ) r2 ON r1.lottery_type = r2.lottery_type AND r1.id = r2.max_id
    ";
    $stmt_latest = $pdo->query($sql_latest_results);
    $latest_results_raw = $stmt_latest->fetchAll(PDO::FETCH_ASSOC);

    $latest_results = [];
    foreach ($latest_results_raw as $row) {
        foreach(['winning_numbers', 'zodiac_signs', 'colors'] as $key) {
            $row[$key] = json_decode($row[$key]) ?: [];
        }
        $latest_results[$row['lottery_type']] = $row;
    }

    // --- 4. 组合并返回一个包含所有信息的“大礼包” ---
    http_response_code(200);
    echo json_encode([
        'status' => 'success',
        'data' => [
            'email_content' => $clean_content,
            'bet_batches' => $bet_batches,
            'latest_lottery_results' => $latest_results // 将最新开奖结果一并返回
        ]
    ]);

} catch (Throwable $e) {
    error_log("Error in get_email_details.php for email_id {$email_id}: " . $e->getMessage());
    http_response_code(500);
    echo json_encode(['status' => 'error', 'message' => 'Internal Server Error.']);
}
?>

---
File: backend/auth/get_emails.php
<?php
// File: backend/auth/get_emails.php

// 核心依赖由 index.php 加载，这里我们直接使用

// 1. 身份验证检查
if (!isset($_SESSION['user_id'])) {
    http_response_code(401); // Unauthorized
    echo json_encode(['status' => 'error', 'message' => '您需要登录才能查看邮件。']);
    exit;
}

$user_id = $_SESSION['user_id'];
$limit = 20; // 限制一次最多获取20封邮件

try {
    $pdo = get_db_connection();

    // 2. 从数据库查询邮件
    // 我们只查询 raw_emails 表，因为前端列表只需要邮件的基本信息
    // 关键：WHERE user_id = ? 确保了用户只能看到自己的邮件
    $stmt = $pdo->prepare(
        "SELECT id, status, received_at
         FROM raw_emails
         WHERE user_id = ?
         ORDER BY received_at DESC
         LIMIT ?"
    );

    // PDO::PARAM_INT 告诉数据库这是一个整数，更安全
    $stmt->bindParam(1, $user_id, PDO::PARAM_INT);
    $stmt->bindParam(2, $limit, PDO::PARAM_INT);
    $stmt->execute();

    $emails = $stmt->fetchAll(PDO::FETCH_ASSOC);

    // 3. 返回成功响应
    http_response_code(200);
    echo json_encode(['status' => 'success', 'data' => $emails]);

} catch (PDOException $e) {
    error_log("Error fetching emails for user {$user_id}: " . $e->getMessage());
    http_response_code(500);
    echo json_encode(['status' => 'error', 'message' => '获取邮件列表时发生数据库错误。']);
}
?>

---
File: backend/auth/login.php
<?php
// File: backend/auth/login.php

require_once __DIR__ . '/../db_operations.php';

// 1. 获取 POST 请求的 JSON 数据
$data = json_decode(file_get_contents('php://input'), true);
$email = $data['email'] ?? null;
$password = $data['password'] ?? null;

// 2. 基本验证
if (empty($email) || empty($password)) {
    http_response_code(400); // Bad Request
    echo json_encode(['status' => 'error', 'message' => '邮箱和密码不能为空。']);
    exit;
}

try {
    // 3. 从数据库中查找用户
    $pdo = get_db_connection();
    $stmt = $pdo->prepare("SELECT id, email, password_hash, status FROM users WHERE email = ?");
    $stmt->execute([$email]);
    $user = $stmt->fetch(PDO::FETCH_ASSOC);

    // 4. 验证用户是否存在、密码是否正确以及账户状态
    if ($user && password_verify($password, $user['password_hash'])) {

        // 检查用户是否被封禁
        if ($user['status'] === 'banned') {
            http_response_code(403); // Forbidden
            echo json_encode(['status' => 'error', 'message' => '您的账户已被封禁。']);
            exit;
        }

        // 5. 密码正确，创建 Session
        // api_header.php 已经调用了 session_start()
        session_regenerate_id(true); // 防止会话固定攻击
        $_SESSION['user_id'] = $user['id'];
        $_SESSION['user_email'] = $user['email'];

        // 6. 返回成功响应和用户信息
        http_response_code(200);
        echo json_encode([
            'status' => 'success',
            'message' => '登录成功！',
            'user' => [
                'id' => $user['id'],
                'email' => $user['email']
            ]
        ]);

    } else {
        // 用户不存在或密码错误
        http_response_code(401); // Unauthorized
        echo json_encode(['status' => 'error', 'message' => '邮箱或密码错误。']);
    }

} catch (PDOException $e) {
    // 数据库错误
    error_log("Login Error: " . $e->getMessage()); // 记录错误日志
    http_response_code(500);
    echo json_encode(['status' => 'error', 'message' => '服务器内部错误，请稍后再试。']);
}
?>

---
File: backend/auth/logout.php
<?php
// File: backend/auth/logout.php

// api_header.php 已经启动了 session, 所以我们可以直接操作它

// 1. 清空所有 session 变量
$_SESSION = [];

// 2. 删除 session cookie
// 这是确保浏览器删除会话标识的关键步骤
if (ini_get("session.use_cookies")) {
    $params = session_get_cookie_params();
    setcookie(session_name(), '', time() - 42000,
        $params["path"], $params["domain"],
        $params["secure"], $params["httponly"]
    );
}

// 3. 销毁服务器上的 session 数据
session_destroy();

// 4. 返回成功响应
http_response_code(200);
echo json_encode(['status' => 'success', 'message' => '登出成功！']);
?>

---
File: backend/auth/register.php
<?php // backend/auth/register.php
require_once __DIR__ . '/../db_operations.php';

$data = json_decode(file_get_contents('php://input'), true);
$email = $data['email'] ?? null;
$password = $data['password'] ?? null;

if (!$email || !$password) {
    http_response_code(400);
    echo json_encode(['status' => 'error', 'message' => 'Email and password are required.']);
    exit;
}

try {
    $pdo = get_db_connection();
    $stmt = $pdo->prepare("SELECT id FROM users WHERE email = ?");
    $stmt->execute([$email]);
    if ($stmt->fetch()) {
        http_response_code(409);
        echo json_encode(['status' => 'error', 'message' => 'Email already registered.']);
        exit;
    }

    $hash = password_hash($password, PASSWORD_DEFAULT);
    $stmt = $pdo->prepare("INSERT INTO users (email, password_hash) VALUES (?, ?)");
    $stmt->execute([$email, $hash]);

    echo json_encode(['status' => 'success', 'message' => 'Registration successful.']);
} catch (PDOException $e) {
    http_response_code(500);
    echo json_encode(['status' => 'error', 'message' => 'Database error.']);
}
?>

---
File: backend/auth/update_bet_batch.php
<?php
// File: backend/auth/update_bet_batch.php (Complete Version)

// 1. 身份验证
if (!isset($_SESSION['user_id'])) {
    http_response_code(401);
    echo json_encode(['status' => 'error', 'message' => 'Unauthorized']);
    exit;
}

// 2. 获取并验证输入
$input = json_decode(file_get_contents('php://input'), true);
$batch_id = $input['batch_id'] ?? null;
$updated_data = $input['data'] ?? null; // The new JSON object/array for bet_data_json

if (empty($batch_id) || !is_numeric($batch_id) || $updated_data === null) {
    http_response_code(400);
    echo json_encode(['status' => 'error', 'message' => 'Invalid input: batch_id and data are required.']);
    exit;
}

// 将接收到的新数据重新编码为 JSON 字符串
$updated_data_json = json_encode($updated_data);
if ($updated_data_json === false) {
    http_response_code(400);
    echo json_encode(['status' => 'error', 'message' => 'Invalid JSON data provided.']);
    exit;
}

try {
    $pdo = get_db_connection();

    // 3. 安全性检查 (非常重要!)
    // 在更新前，必须确认这条 bet batch 记录确实属于当前登录的用户。
    // 我们通过 parsed_bets -> raw_emails -> users 的连接来实现。
    $stmt_check = $pdo->prepare("
        SELECT pb.id FROM parsed_bets pb
        JOIN raw_emails re ON pb.email_id = re.id
        WHERE pb.id = ? AND re.user_id = ?
    ");
    $stmt_check->execute([$batch_id, $_SESSION['user_id']]);

    if ($stmt_check->fetchColumn() === false) {
        // 如果查询没有返回任何结果，说明这条记录不属于当前用户
        http_response_code(403); // Forbidden
        echo json_encode(['status' => 'error', 'message' => 'Access denied: You do not own this bet batch.']);
        exit;
    }

    // 4. 执行更新
    $stmt_update = $pdo->prepare("UPDATE parsed_bets SET bet_data_json = ? WHERE id = ?");
    $stmt_update->execute([$updated_data_json, $batch_id]);

    if ($stmt_update->rowCount() > 0) {
        // 更新成功
        http_response_code(200);
        echo json_encode(['status' => 'success', 'message' => 'Bet batch updated successfully.']);
    } else {
        // rowCount() 为 0 可能意味着记录存在，但提交的数据与库中数据完全相同，未发生实际更新。
        // 这也应该被视为一种成功。
        http_response_code(200);
        echo json_encode(['status' => 'success', 'message' => 'No changes detected, but acknowledged.']);
    }

} catch (PDOException $e) {
    error_log("Error updating bet batch {$batch_id}: " . $e->getMessage());
    http_response_code(500);
    echo json_encode(['status' => 'error', 'message' => 'A database error occurred during the update.']);
}
?>

---
File: backend/helpers/mail_parser.php
<?php
// File: backend/helpers/mail_parser.php

if (!function_exists('parse_email_body')) {
    /**
     * 从原始 MIME 邮件文本中解析并解码出最合适的用户正文。
     * 优先提取 text/plain 部分。
     *
     * @param string $raw_email 完整的原始邮件内容。
     * @return string 清理和解码后的正文文本。
     */
    function parse_email_body(string $raw_email): string {
        // 1. 分离邮件头和邮件体
        $parts = explode("\r\n\r\n", $raw_email, 2);
        if (count($parts) !== 2) {
            return $raw_email; // 格式不规范，返回原文
        }
        list($headers_raw, $body_raw) = $parts;

        // 2. 解析邮件头的 Content-Type
        if (!preg_match('/Content-Type: (.*)/i', $headers_raw, $matches)) {
            return $body_raw; // 没有 Content-Type，直接返回邮件体
        }
        $content_type_header = $matches[1];

        // 3. 如果不是 multipart 邮件，直接解码邮件体
        if (strpos(strtolower($content_type_header), 'multipart/') === false) {
            if (preg_match('/Content-Transfer-Encoding: (base64|quoted-printable)/i', $headers_raw, $encoding_match)) {
                return decode_body_part($body_raw, $encoding_match[1]);
            }
            return $body_raw;
        }

        // 4. 如果是 multipart 邮件，解析 boundary
        if (!preg_match('/boundary="?([^"]+)"?/i', $content_type_header, $boundary_match)) {
            return $body_raw; // 找不到 boundary，无法解析
        }
        $boundary = $boundary_match[1];

        // 5. 按 boundary 分割邮件体
        $body_parts = explode('--' . $boundary, $body_raw);
        array_shift($body_parts); // 移除第一个空部分
        array_pop($body_parts);   // 移除最后一个 '--' 结尾的部分

        $plain_text_body = '';
        $html_body = '';

        // 6. 遍历每个部分，寻找 text/plain 和 text/html
        foreach ($body_parts as $part) {
            if (empty(trim($part))) continue;

            $part_parts = explode("\r\n\r\n", $part, 2);
            if (count($part_parts) !== 2) continue;
            list($part_header_raw, $part_body_raw) = $part_parts;

            // 检查当前部分的 Content-Type
            if (preg_match('/Content-Type: text\/plain/i', $part_header_raw)) {
                if (preg_match('/Content-Transfer-Encoding: (base64|quoted-printable)/i', $part_header_raw, $encoding_match)) {
                    $plain_text_body = decode_body_part($part_body_raw, $encoding_match[1]);
                } else {
                    $plain_text_body = $part_body_raw;
                }
            } elseif (preg_match('/Content-Type: text\/html/i', $part_header_raw)) {
                if (preg_match('/Content-Transfer-Encoding: (base64|quoted-printable)/i', $part_header_raw, $encoding_match)) {
                    // 解码HTML并去除所有HTML标签，得到纯文本
                    $html_body = strip_tags(decode_body_part($part_body_raw, $encoding_match[1]));
                } else {
                    $html_body = strip_tags($part_body_raw);
                }
            }
        }

        // 7. 优先返回纯文本正文，如果不存在则返回从HTML中提取的文本
        return trim($plain_text_body) ?: trim($html_body) ?: '无法解析邮件正文';
    }
}

if (!function_exists('decode_body_part')) {
    /**
     * 解码 base64 或 quoted-printable 编码的邮件体部分。
     * @param string $body
     * @param string $encoding
     * @return string
     */
    function decode_body_part(string $body, string $encoding): string {
        $encoding = strtolower(trim($encoding));
        if ($encoding === 'base64') {
            return base64_decode($body);
        } elseif ($encoding === 'quoted-printable') {
            return quoted_printable_decode($body);
        }
        return $body; // 如果编码不认识，返回原文
    }
}
?>

---
File: backend/lottery/get_result_by_issue.php
<?php
// File: backend/lottery/get_result_by_issue.php

// 核心依赖由 index.php 加载

$issue = $_GET['issue'] ?? null;
$type = $_GET['type'] ?? null;

if (empty($issue) || empty($type)) {
    http_response_code(400);
    echo json_encode(['status' => 'error', 'message' => '彩票类型 (type) 和期号 (issue) 都是必须的。']);
    exit;
}

try {
    $pdo = get_db_connection();

    $stmt = $pdo->prepare(
        "SELECT * FROM lottery_results
         WHERE issue_number = ? AND lottery_type = ?
         ORDER BY id DESC LIMIT 1"
    );
    $stmt->execute([$issue, $type]);

    $result = $stmt->fetch(PDO::FETCH_ASSOC);

    if ($result) {
        // 将 JSON 字符串字段解码为 PHP 数组
        foreach (['winning_numbers', 'zodiac_signs', 'colors'] as $key) {
            $result[$key] = json_decode($result[$key]);
        }
        http_response_code(200);
        echo json_encode(['status' => 'success', 'data' => $result]);
    } else {
        http_response_code(404);
        echo json_encode(['status' => 'error', 'message' => "找不到类型 '{$type}' 的期号 '{$issue}' 的开奖结果。"]);
    }

} catch (PDOException $e) {
    error_log("获取指定开奖结果时出错: " . $e->getMessage());
    http_response_code(500);
    echo json_encode(['status' => 'error', 'message' => '数据库查询失败。']);
}
?>

---
File: backend/lottery/get_results.php
<?php
// File: backend/lottery/get_results.php

// 核心依赖由 index.php 加载

$type = $_GET['type'] ?? 'all'; // 默认为 'all'
$limit = isset($_GET['limit']) ? (int)$_GET['limit'] : 10;

// 基本的输入验证
if ($limit <= 0 || $limit > 100) {
    $limit = 10; // 默认值
}

try {
    $pdo = get_db_connection();

    $sql = "SELECT * FROM lottery_results";
    $params = [];

    if ($type !== 'all') {
        $sql .= " WHERE lottery_type = ?";
        $params[] = $type;
    }

    $sql .= " ORDER BY id DESC LIMIT ?";
    $params[] = $limit;

    $stmt = $pdo->prepare($sql);
    $stmt->execute($params);

    $results = $stmt->fetchAll(PDO::FETCH_ASSOC);

    // 将所有结果中的 JSON 字符串字段解码为 PHP 数组
    $results = array_map(function($row) {
        foreach (['winning_numbers', 'zodiac_signs', 'colors'] as $key) {
            $row[$key] = json_decode($row[$key]);
        }
        return $row;
    }, $results);

    http_response_code(200);
    echo json_encode(['status' => 'success', 'data' => $results]);

} catch (PDOException $e) {
    error_log("获取开奖结果列表时出错: " . $e->getMessage());
    http_response_code(500);
    echo json_encode(['status' => 'error', 'message' => '数据库查询失败。']);
}
?>

---
File: backend/lottery/rules.php
<?php
// File: backend/lottery/rules.php

// 这个文件目前只是一个占位符，未来可以从这里提供游戏规则
// 比如，可以从一个配置文件或数据库加载规则

$rules = [
    '香港六合彩' => [
        'description' => '香港六合彩是一种基于49个号码的彩票游戏...',
        'bet_types' => ['特码', '平码', '生肖', '色波']
    ],
    '澳门六合彩' => [
        'description' => '澳门六合彩规则与香港六合彩类似...',
        'bet_types' => ['特码', '平码', '大小', '单双']
    ]
];

// 默认情况下，这个端点不是公开的，需要通过 index.php 路由
// 如果需要，可以在 index.php 的 $routes 中添加它
// 'get_lottery_rules' => 'lottery/rules.php',

http_response_code(200);
echo json_encode(['status' => 'success', 'data' => $rules]);
?>

---
File: backend/mail/receive.php
<?php
// File: backend/mail/receive.php
// This is a placeholder for the mail receiver logic.
// The actual implementation is in mail_receiver_light.php
http_response_code(200);
echo json_encode(['status' => 'success', 'message' => 'Mail receiver placeholder.']);
?>

---
File: backend/telegram/parser.php
<?php
// File: backend/telegram/parser.php

if (!function_exists('parse_lottery_result')) {
    /**
     * 从给定的文本中解析出彩票开奖结果。
     * @param string $text
     * @return array|null
     */
    function parse_lottery_result(string $text): ?array {
        // 匹配 "香港" 或 "澳门" 六合彩
        if (!preg_match('/(香港|澳门)六合彩\s+(\d{4}\/\d{3})期/', $text, $matches)) {
            return null;
        }

        $result = [];
        $result['lottery_type'] = $matches[1] . '六合彩';
        $result['issue_number'] = $matches[2];

        // 提取正码
        if (preg_match('/正码:\s*([\d\s,]+)/', $text, $matches)) {
            $result['winning_numbers']['regular'] = preg_split('/[\s,]+/', trim($matches[1]));
        }

        // 提取特码
        if (preg_match('/特码:\s*(\d+)/', $text, $matches)) {
            $result['winning_numbers']['special'] = $matches[1];
        }

        // 提取生肖
        if (preg_match('/特码生肖:\s*([\p{L}\s,]+)/u', $text, $matches)) {
            $result['zodiac_signs'] = preg_split('/[\s,]+/', trim($matches[1]));
        }

        // 提取色波
        if (preg_match('/色波:\s*([\p{L}\s,]+)/u', $text, $matches)) {
            $result['colors'] = preg_split('/[\s,]+/', trim($matches[1]));
        }

        return $result;
    }
}
?>

---
File: backend/telegram/receiver.php
<?php
// File: backend/telegram/receiver.php (Final Secure Version)

// --- 独立的日志记录 (避免依赖 config.php) ---
define('TELEGRAM_LOG_FILE', __DIR__ . '/telegram_debug.log');
function log_telegram($message) {
    error_log(date('[Y-m-d H:i:s] ') . $message . "\n", 3, TELEGRAM_LOG_FILE);
}

log_telegram("--- Webhook triggered ---");

try {
    // --- 1. 独立的 .env 加载器 (不依赖 config.php) ---
    if (!function_exists('load_env_for_telegram')) {
        function load_env_for_telegram() {
            $envPath = __DIR__ . '/../.env';
            if (file_exists($envPath)) {
                $lines = file($envPath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
                foreach ($lines as $line) {
                    if (strpos(trim($line), ';') === 0) continue;
                    if (strpos($line, ';') !== false) $line = substr($line, 0, strpos($line, ';'));
                    if (strpos($line, '=') !== false) {
                        list($name, $value) = explode('=', $line, 2);
                        // 使用 putenv, 这样 getenv 就能工作
                        putenv(trim($name) . "=" . trim(trim($value), "\"'"));
                    }
                }
            } else {
                log_telegram("FATAL: .env file not found at {$envPath}");
            }
        }
    }
    load_env_for_telegram();
    log_telegram(".env loaded");

    // --- 2. 安全检查: 验证来自 URL 的密钥 ---
    $url_secret = $_GET['secret'] ?? null;
    $env_secret = getenv('TELEGRAM_WEBHOOK_SECRET');

    if (!$env_secret || !$url_secret || !hash_equals($env_secret, $url_secret)) {
        log_telegram("Forbidden: Missing or invalid secret in URL.");
        http_response_code(403);
        exit;
    }
    log_telegram("URL secret verified.");

    // --- 3. 接收并解析输入 ---
    $input = file_get_contents('php://input');
    if (!$input) {
        log_telegram("Received empty input.");
        http_response_code(200);
        exit;
    }
    log_telegram("Raw input: " . $input);

    $update = json_decode($input, true);
    if (!$update) {
        log_telegram("Failed to decode JSON.");
        http_response_code(200);
        exit;
    }

    // --- 4. 提取消息文本 ---
    $message = $update['channel_post']['text'] ?? null;
    if (!$message) {
        log_telegram("No message text found in channel post.");
        http_response_code(200);
        exit;
    }
    log_telegram("Message text: " . $message);

    // --- 5. 调用解析器 ---
    require_once __DIR__ . '/parser.php';
    $parsed_data = parse_lottery_result($message);

    if ($parsed_data) {
        log_telegram("Parsing successful: " . json_encode($parsed_data));

        // --- 6. 数据库操作 ---
        $dsn = sprintf("mysql:host=%s;port=%s;dbname=%s;charset=utf8mb4",
            getenv('DB_HOST'), getenv('DB_PORT'), getenv('DB_DATABASE')
        );
        $pdo = new PDO($dsn, getenv('DB_USERNAME'), getenv('DB_PASSWORD'), [PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION]);
        log_telegram("Database connected.");

        $stmt = $pdo->prepare("
            INSERT INTO lottery_results
            (lottery_type, issue_number, winning_numbers, zodiac_signs, colors, drawing_date)
            VALUES (:type, :issue, :win_num, :zodiac, :colors, CURDATE())
            ON DUPLICATE KEY UPDATE
            winning_numbers = VALUES(winning_numbers),
            zodiac_signs = VALUES(zodiac_signs),
            colors = VALUES(colors)
        ");

        $stmt->execute([
            ':type' => $parsed_data['lottery_type'],
            ':issue' => $parsed_data['issue_number'],
            ':win_num' => json_encode($parsed_data['winning_numbers']),
            ':zodiac' => json_encode($parsed_data['zodiac_signs']),
            ':colors' => json_encode($parsed_data['colors'])
        ]);
        log_telegram("Database operation successful. Rows affected: " . $stmt->rowCount());

    } else {
        log_telegram("Parsing failed. No lottery data found.");
    }

} catch (Throwable $e) {
    log_telegram("--- ERROR ---");
    log_telegram("Error: " . $e->getMessage());
    log_telegram("File: " . $e->getFile() . " on line " . $e->getLine());
}

// 始终返回 200 OK，告知 Telegram 我们已收到
http_response_code(200);
echo "OK";
log_telegram("--- Webhook finished ---\n");
?>
