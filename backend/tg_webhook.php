<?php\n\nrequire_once __DIR__ . \'/vendor/autoload.php\';\n\nuse App\\Lib\\LotteryParser;\nuse App\\Lib\\User;\nuse App\\Lib\\Telegram;\nuse App\\Lib\\Lottery;\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\nuse Dotenv\\Dotenv;\n\n// Load .env variables\n$dotenv = Dotenv::createImmutable(__DIR__);\n$dotenv->load();\n\n// Logger Setup\n$logLevel = Logger::toMonologLevel($_ENV[\'LOG_LEVEL\'] ?? \'INFO\');\n$log = new Logger(\'telegram_webhook\');\n$log->pushHandler(new StreamHandler(__DIR__ . \'/app.log\', $logLevel));\n\n// Database Connection\ntry {\n    $dsn = \"mysql:host={\$_ENV[\'DB_HOST\']};dbname={\$_ENV[\'DB_NAME\']};charset=utf8mb4\";\n    $options = [\n        PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,\n        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,\n        PDO::ATTR_EMULATE_PREPARES   => false,\n    ];\n    $pdo = new PDO($dsn, $_ENV[\'DB_USER\'], $_ENV[\'DB_PASS\'], $options);\n} catch (PDOException $e) {\n    $log->error(\"Database connection failed in tg_webhook: \" . $e->getMessage());\n    http_response_code(500);\n    echo json_encode([\'status\' => \'error\', \'message\' => \'Database connection failed.\']);\n    exit();\n}\n\n// Telegram Bot Token and Admin ID from environment variables\n$botToken = $_ENV[\'TELEGRAM_BOT_TOKEN\'] ?? \'\';\n$adminId = $_ENV[\'TELEGRAM_ADMIN_ID\'] ?? \'\';\n\nif (empty($botToken) || empty($adminId)) {\n    $log->error(\"Telegram BOT_TOKEN or ADMIN_ID is not set in environment variables.\");\n    http_response_code(500);\n    echo json_encode([\'status\' => \'error\', \'message\' => \'Bot configuration error.\']);\n    exit();\n}\n\n$telegram = new Telegram($botToken, $log);\n\n// Get and Decode the Incoming Update\n$update_json = file_get_contents(\'php://input\');\n$update = json_decode($update_json, true);\n$log->info(\"Incoming Telegram update: \" . $update_json);\n\n// 4. Process Callback Queries (Button Presses)\nif (isset($update[\'callback_query\'])) {\n    $callback_query = $update[\'callback_query\'];\n    $callback_id = $callback_query[\'id\'];\n    $callback_data = $callback_query[\'data\'];\n    $query_from_id = $callback_query[\'from\'][\'id\'] ?? null;\n\n    if ($query_from_id == $adminId) {\n        $parts = explode(\'_\', $callback_data);\n        $action = $parts[0];\n        // Existing user approval/denial logic is commented out as per previous note.\n        // It can be re-enabled or removed based on final requirements.\n\n        // For now, just answer the callback to remove the loading state in Telegram\n        $telegram->answerCallbackQuery($callback_id, \'功能暂未启用或已废弃.\');\n    } else {\n        $telegram->answerCallbackQuery($callback_id, \'抱歉，您无权执行此操作。\', true);\n        $log->warning(\"Unauthorized callback query from user ID: \" . $query_from_id);\n    }\n    http_response_code(200);\n    exit();\n}\n\n// 5. Process Regular Messages\n$message = null;\nif (isset($update[\'message\'])) {\n    $message = $update[\'message\'];\n} elseif (isset($update[\'channel_post\'])) {\n    $message = $update[\'channel_post\'];\n}\n\nif ($message) {\n    $chat_id = $message[\'chat\'][\'id\'];\n    $user_id = $message[\'from\'][\'id\'] ?? null;\n    $text = trim($message[\'text\'] ?? \'\');\n\n    // --- Step 1: Attempt to parse any message as a lottery result first. ---
    $parsedResult = LotteryParser::parse($text);\n    if ($parsedResult) {\n        $statusMessage = Lottery::saveLotteryResultToDB($pdo, $parsedResult);\n        if ($chat_id != $adminId) {\n            // Optionally notify the admin if a public channel posts a result\n            $channel_title = isset($message[\'chat\'][\'title\']) ? \" from channel \"\" . htmlspecialchars($message[\'chat\'][\'title\']) . \"\" : \"\";\n            $telegram->sendMessage($adminId, \"Successfully parsed a new result\" . $channel_title . \":\\n`\" . $parsedResult[\'lottery_name\'] . \" - \" . $parsedResult[\'issue_number\'] . \"`\\n\\nStatus: *\" . $statusMessage . \"*\");\n        } else {\n            $telegram->sendMessage($chat_id, \"成功识别到开奖结果：\\n`\" . $parsedResult[\'lottery_name\'] . \" - \" . $parsedResult[\'issue_number\'] . \"`\\n\\n状态: *\" . $statusMessage . \"*\");\n        }\n        http_response_code(200);\n        exit();\n    }\n\n    // --- Step 2: If it\'s not a parsable result, check if the sender is the admin. ---
    if ($user_id !== (int)$adminId) {\n        if ($chat_id === $user_id) { // Only respond to private chats from non-admins\n            $telegram->sendMessage($chat_id, \"抱歉，此机器人功能仅限管理员使用。\");\n        }\n        $log->warning(\"Unauthorized message from user ID: \" . $user_id . \" in chat ID: \" . $chat_id . \" with text: \" . $text);\n        http_response_code(403); // Forbidden for non-admins trying to use commands\n        exit();\n    }\n\n    // --- Step 3: Admin-only logic ---
    $main_menu_keyboard = [\'keyboard\' => [[\'text\' => \'👤 用户管理\'], [\'text\' => \'⚙️ 系统设置\']], \'resize_keyboard\' => true];\n    $user_management_keyboard = [\'keyboard\' => [[\'text\' => \'📋 列出所有用户\'], [\'text\' => \'➖ 删除用户\']], [\'text\' => \'⬅️ 返回主菜单\']], \'resize_keyboard\' => true];\n    $system_settings_keyboard = [\'keyboard\' => [[\'text\' => \'🔑 设定API密钥\'], [\'text\' => \'ℹ️ 检查密钥状态\']], [\'text\' => \'⬅️ 返回主菜单\']], \'resize_keyboard\' => true];\n\n    $command_map = [\n        \'👤 用户管理\' => \'/user_management\',\n        \'⚙️ 系统设置\' => \'/system_settings\',\n        \'➖ 删除用户\' => \'/deluser\',\n        \'📋 列出所有用户\' => \'/listusers\',\n        \'🔑 设定API密钥\' => \'/set_gemini_key\',\n        \'ℹ️ 检查密钥状态\' => \'/get_api_key_status\',\n        \'⬅️ 返回主菜单\' => \'/start\',\n    ];\n\n    $command = null;\n    $args = \'\';\n\n    if (isset($command_map[$text])) {\n        $command = $command_map[$text];\n    } else if (strpos($text, \'/\') === 0) {\n        $parts = explode(\' \', $text, 2);\n        $command = $parts[0];\n        $args = $parts[1] ?? \'\';\n    }\n\n    if ($command) {\n        switch ($command) {\n            case \'/start\':\n                $telegram->sendMessage($chat_id, \"欢迎回来，管理员！请选择一个操作：\", $main_menu_keyboard);\n                break;\n            case \'/user_management\':\n                $telegram->sendMessage($chat_id, \"👤 *用户管理*\\n\\n请选择一个操作：\", $user_management_keyboard);\n                break;\n            case \'/system_settings\':\n                $telegram->sendMessage($chat_id, \"⚙️ *系统设置*\\n\\n请选择一个操作：\", $system_settings_keyboard);\n                break;\n            case \'/deluser\':\n                $responseText = !empty($args) ? User::deleteUserFromDB($pdo, $args) : \"用法：`/deluser <telegram_id>`\";\n                $telegram->sendMessage($chat_id, $responseText);\n                break;\n            case \'/listusers\':\n                $telegram->sendMessage($chat_id, User::listUsersFromDB($pdo));\n                break;\n            case \'/set_gemini_key\':\n                // Placeholder for Gemini API Key setting logic\n                $telegram->sendMessage($chat_id, \"此功能暂未完全实现。\");\n                break;\n            case \'/get_api_key_status\':\n                // Placeholder for Gemini API Key status checking logic\n                $telegram->sendMessage($chat_id, \"此功能暂未完全实现。\");\n                break;\n            default:\n                $telegram->sendMessage($chat_id, \"抱歉，我不理解该命令。\");\n                break;\n        }\n    } else if ($chat_id == $adminId && !empty($text)) {\n        // If it's the admin and not a command, try to parse as lottery result (already done above)
        // Or handle other admin-specific free text input if needed.\n        $telegram->sendMessage($chat_id, \"抱歉，我无法识别您的输入。请使用菜单或有效命令。\");\n    }\n}\n\nhttp_response_code(200);\necho json_encode([\'status\' => \'ok\']);\n