<?php\ndeclare(strict_types=1);\n\nnamespace App\\Controllers;\n\nclass EmailController extends BaseController\n{\n    /**\n     * Handles email-related API requests based on HTTP method and URL path.\n     */\n    public function handleEmails(): void\n    {\n        $method = $_SERVER[\'REQUEST_METHOD\'];\n        $path = $_SERVER[\'REQUEST_URI\'] ?? \'/\';\n        $pathParts = explode(\'/\', trim($path, \'/\'));\n\n        // Check for an ID in the URL, e.g., /api/emails/123\n        $emailId = null;\n        if (isset($pathParts[2]) && is_numeric($pathParts[2])) {\n            $emailId = (int)$pathParts[2];\n        }\n\n        switch ($method) {\n            case \'GET\':\n                if ($emailId) {\n                    $this->getEmail($emailId);\n                }\ else {\n                    $this->listEmails();\n                }\n                break;\n            case \'POST\':\n                $this->saveEmail();\n                break;\n            default:\n                $this->jsonError(405, \'Method Not Allowed\');\n                break;\n        }\n    }\n\n    /**\n     * Lists emails for the authenticated user.\n     * Requires user_id in session.\n     */\n    private function listEmails(): void\n    {\n        if (!isset($_SESSION[\'user_id\'])) {\n            $this->jsonError(401, \'Unauthorized\');\n        }\n\n        try {\n            $pdo = $this->getDbConnection();\n            // Ensure selection includes all necessary fields or specific ones for performance\n            $stmt = $pdo->prepare(\"SELECT id, sender, subject, received_at FROM emails WHERE user_id = ? ORDER BY received_at DESC\");\n            $stmt->execute([$_SESSION[\'user_id\']]);\n            $emails = $stmt->fetchAll();\n            $this->jsonResponse(200, [\'status\' => \'success\', \'data\' => $emails]);\n        } catch (\\PDOException $e) {\n            // Delegate to unified error handler\n            $this->jsonError(500, \'Database error while listing emails.\', $e);\n        }\n    }\n\n    /**\n     * Retrieves a single email for the authenticated user by ID.\n     * Requires user_id in session.\n     *\n     * @param int $id The ID of the email to retrieve.\n     */\n    private function getEmail(int $id): void\n    {\n        if (!isset($_SESSION[\'user_id\'])) {\n            $this->jsonError(401, \'Unauthorized\');\n        }\n\n        try {\n            $pdo = $this->getDbConnection();\n            $stmt = $pdo->prepare(\"SELECT * FROM emails WHERE id = ? AND user_id = ?\");\n            $stmt->execute([$id, $_SESSION[\'user_id\']]);\n            $email = $stmt->fetch();\n\n            if ($email) {\n                $this->jsonResponse(200, [\'status\' => \'success\', \'data\' => $email]);\n            } else {\n                $this->jsonError(404, \'Email not found or access denied.\');\n            }\n        } catch (\\PDOException $e) {\n            // Delegate to unified error handler\n            $this->jsonError(500, \'Database error while retrieving email.\', $e);\n        }\n    }\n\n    /**\n     * Saves a new email to the database.\n     * Requires a valid worker_secret for authorization.\n     */\n    private function saveEmail(): void\n    {\n        try {\n            $data = $this->getJsonBody(); // This can now throw InvalidArgumentException\n\n            // 1. Security Check: Verify worker secret using hash_equals for timing attack prevention\n            $workerSecret = $data[\'worker_secret\'] ?? \'\';\n            $expectedSecret = $_ENV[\'WORKER_SECRET\'] ?? \'\';\n\n            if (empty($workerSecret) || empty($expectedSecret) || !hash_equals($expectedSecret, $workerSecret)) {\n                $this->jsonError(403, \'Forbidden: Invalid or missing secret.\');\n            }\n\n            // 2. Input Validation\n            $from = $data[\'from\'] ?? null;\n            $subject = $data[\'subject\'] ?? null;\n            $body = $data[\'body\'] ?? null;\n            $userId = $data[\'user_id\'] ?? null;\n\n            // Basic validation: Check for existence and type/length where appropriate\n            if (empty($from) || !filter_var($from, FILTER_VALIDATE_EMAIL)) {\n                throw new \\InvalidArgumentException(\'Invalid or missing sender email.\');\n            }\n            if (empty($subject) || !is_string($subject) || strlen($subject) > 255) {\n                throw new \\InvalidArgumentException(\'Invalid or missing subject.\');\n            }\n            if (empty($body) || !is_string($body)) {\n                throw new \\InvalidArgumentException(\'Invalid or missing email body.\');\n            }\n            if (empty($userId) || !is_numeric($userId) || (int)$userId <= 0) {\n                throw new \\InvalidArgumentException(\'Invalid or missing user ID.\');\n            }\n            $userId = (int)$userId;\n\n            // 3. Database Insertion\n            $pdo = $this->getDbConnection();\n            $stmt = $pdo->prepare(\n                \"INSERT INTO emails (user_id, sender, subject, body, received_at) VALUES (?, ?, ?, ?, NOW())\"\n            );\n\n            if ($stmt->execute([$userId, $from, $subject, $body])) {\n                $this->jsonResponse(201, [\'status\' => \'success\', \'message\' => \'Email saved successfully.\', \'email_id\' => $pdo->lastInsertId()]);\n            } else {\n                // This part should ideally not be reached if PDO::ATTR_ERRMODE is EXCEPTION\n                $this->jsonError(500, \'Failed to save email.\');\n            }\n        } catch (\\InvalidArgumentException $e) {\n            // Catch validation errors and return 400 Bad Request\n            $this->jsonError(400, $e->getMessage(), $e);\n        } catch (\\PDOException $e) {\n            // Catch database errors\n            $this->jsonError(500, \'Database error while saving email.\', $e);\n        } catch (\\Throwable $e) {\n            // Catch any other unexpected errors\n            $this->jsonError(500, \'An unexpected error occurred while saving email.\', $e);\n        }\n    }\n}\n