<?php\n\n/**\n * Updates a specific key in the .env file.\n *\n * This function reads the .env file, line by line, and updates the value\n * for the specified key. It preserves comments and blank lines.\n *\n * @param string $keyToUpdate The environment variable key to update (e.g., \'GEMINI_API_KEY\').\n * @param string $newValue    The new value for the key.\n * @return bool True on success, false on failure.\n */\nfunction update_env_file($keyToUpdate, $newValue) {\n    $envPath = __DIR__ . \'/.env\';\n\n    if (!file_exists($envPath) || !is_readable($envPath) || !is_writable($envPath)) {\n        error_log(\"Error: .env file is missing or not readable/writable at {$envPath}\");\n        return false;\n    }\n\n    $lines = file($envPath, FILE_IGNORE_NEW_LINES);\n    $newLines = [];\n    $keyFound = false;\n\n    foreach ($lines as $line) {\n        // Trim the line to handle whitespace and check if it\'s a key-value pair.\n        if (strpos(trim($line), \'#\') === 0 || empty(trim($line))) {\n            $newLines[] = $line;\n            continue;\n        }\n\n        list($key, $value) = explode(\'=\', $line, 2);\n        $key = trim($key);\n\n        if ($key === $keyToUpdate) {\n            // Update the key with the new value, ensuring it\'s properly quoted if it contains spaces.\n            $newLines[] = \"{$keyToUpdate}=\\\"{$newValue}\\\"\";\n            $keyFound = true;\n        } else {\n            $newLines[] = $line;\n        }\n    }\n\n    // If the key was not found, add it to the end of the file.\n    if (!$keyFound) {\n        $newLines[] = \"{$keyToUpdate}=\\\"{$newValue}\\\"\";\n    }\n\n    // Write the updated content back to the .env file.\n    if (file_put_contents($envPath, implode(\"\\n\", $newLines)) === false) {\n        error_log(\"Error: Failed to write to .env file at {$envPath}\");\n        return false;\n    }\n\n    // --- IMPORTANT: Reload environment variables ---\n    // Use putenv to update the environment for the currently running script.\n    putenv(\"{$keyToUpdate}={$newValue}\");\n\n    return true;\n}\n\n// --- JWT Helper Functions ---\n\n// Custom base64 URL encode (RFC 4648)\nfunction base64url_encode($data) {\n    return rtrim(strtr(base64_encode($data), \'+\\/\', \'-\_\'), \'=\');\n}\n\n// Custom base64 URL decode (RFC 4648)\nfunction base64url_decode($data) {\n    return base64_decode(strtr($data, \'-\_\', \'+\\/\') . str_repeat(\'=\', 4 - strlen($data) % 4));\n}\n\n/**\n * Generates a JSON Web Token (JWT).\n *\n * @param array $payload The data to encode in the token.\n * @param int $expiration_seconds The time in seconds until the token expires. Defaults to JWT_EXPIRATION from .env.\n * @return string The generated JWT.\n */\nfunction generate_jwt(array $payload, $expiration_seconds = null) {\n    $secret = getenv(\'JWT_SECRET\');\n    if (!$secret) {\n        error_log(\"JWT_SECRET is not set in environment variables.\");\n        return false;\n    }\n\n    $expiration_seconds = $expiration_seconds ?? (int)getenv(\'JWT_EXPIRATION\');\n    if (!$expiration_seconds) {\n        $expiration_seconds = 3600; // Default to 1 hour if not set\n        error_log(\"JWT_EXPIRATION not set, using default 3600 seconds.\");\n    }\n\n    $header = [\n        \'typ\' => \'JWT\',\n        \'alg\' => \'HS256\'\n    ];\n\n    $issuedAt = time();\n    $expire = $issuedAt + $expiration_seconds;\n\n    $payload[\'iat\'] = $issuedAt; // Issued At\n    $payload[\'exp\'] = $expire;    // Expiration Time\n\n    $base64UrlHeader = base64url_encode(json_encode($header));\n    $base64UrlPayload = base64url_encode(json_encode($payload));\n\n    $signature = hash_hmac(\'sha256\', $base64UrlHeader . \".\" . $base64UrlPayload, $secret, true);\n    $base64UrlSignature = base64url_encode($signature);\n\n    return $base64UrlHeader . \".\" . $base64UrlPayload . \".\" . $base64UrlSignature;\n}\n\n/**\n * Verifies a JSON Web Token (JWT).\n *\n * @param string $jwt The JWT to verify.\n * @return array|false The decoded payload if valid, false otherwise.\n */\nfunction verify_jwt(string $jwt) {\n    $secret = getenv(\'JWT_SECRET\');\n    if (!$secret) {\n        error_log(\"JWT_SECRET is not set in environment variables.\");\n        return false;\n    }\n\n    $tokenParts = explode(\'.\', $jwt);\n    if (count($tokenParts) !== 3) {\n        return false; // Malformed token\n    }\n\n    list($base64UrlHeader, $base64UrlPayload, $base64UrlSignature) = $tokenParts;\n\n    $signature_calculated = hash_hmac(\'sha256\', $base64UrlHeader . \".\" . $base64UrlPayload, $secret, true);\n    $base64UrlSignature_calculated = base64url_encode($signature_calculated);\n\n    if ($base64UrlSignature !== $base64UrlSignature_calculated) {\n        error_log(\"JWT Signature verification failed.\");\n        return false; // Signature mismatch\n    }\n\n    $payload = json_decode(base64url_decode($base64UrlPayload), true);\n\n    if (json_last_error() !== JSON_ERROR_NONE) {\n        error_log(\"JWT Payload JSON decode error: \" . json_last_error_msg());\n        return false; // Payload is not valid JSON\n    }\n\n    // Check expiration time\n    if (isset($payload[\'exp\']) && $payload[\'exp\'] < time()) {\n        error_log(\"JWT Expired.\");\n        return false; // Token expired\n    }\n\n    return $payload;\n}\n