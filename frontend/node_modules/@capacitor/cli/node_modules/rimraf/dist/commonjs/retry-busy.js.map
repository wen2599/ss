{"version":3,"file":"retry-busy.js","sourceRoot":"","sources":["../../src/retry-busy.ts"],"names":[],"mappings":";AAAA,qEAAqE;;;AAErE,8CAA4C;AAE5C,yCAAsC;AAEzB,QAAA,UAAU,GAAG,GAAG,CAAA;AAChB,QAAA,IAAI,GAAG,GAAG,CAAA;AACV,QAAA,UAAU,GAAG,EAAE,CAAA;AACf,QAAA,KAAK,GAAG,IAAI,GAAG,CAAC,CAAC,QAAQ,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC,CAAA;AAEpD,MAAM,SAAS,GAAG,CAAI,EAAgC,EAAE,EAAE;IAC/D,MAAM,MAAM,GAAG,KAAK,EAClB,IAAY,EACZ,GAAuB,EACvB,OAAO,GAAG,CAAC,EACX,KAAK,GAAG,CAAC,EACT,EAAE;QACF,MAAM,GAAG,GAAG,GAAG,CAAC,UAAU,IAAI,kBAAU,CAAA;QACxC,MAAM,IAAI,GAAG,GAAG,CAAC,OAAO,IAAI,YAAI,CAAA;QAChC,MAAM,GAAG,GAAG,GAAG,CAAC,UAAU,IAAI,kBAAU,CAAA;QACxC,IAAI,OAAO,GAAG,CAAC,CAAA;QACf,OAAO,IAAI,EAAE,CAAC;YACZ,IAAI,CAAC;gBACH,OAAO,MAAM,EAAE,CAAC,IAAI,CAAC,CAAA;YACvB,CAAC;YAAC,OAAO,EAAE,EAAE,CAAC;gBACZ,IAAI,IAAA,oBAAS,EAAC,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,KAAK,IAAI,IAAI,aAAK,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;oBAC5D,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,CAAA;oBACnC,KAAK,GAAG,OAAO,GAAG,KAAK,CAAA;oBACvB,IAAI,KAAK,GAAG,GAAG,EAAE,CAAC;wBAChB,MAAM,IAAA,qBAAU,EAAC,OAAO,CAAC,CAAA;wBACzB,OAAO,MAAM,CAAC,IAAI,EAAE,GAAG,EAAE,OAAO,EAAE,KAAK,CAAC,CAAA;oBAC1C,CAAC;oBACD,IAAI,OAAO,GAAG,GAAG,EAAE,CAAC;wBAClB,OAAO,EAAE,CAAA;wBACT,SAAQ;oBACV,CAAC;gBACH,CAAC;gBACD,MAAM,EAAE,CAAA;YACV,CAAC;QACH,CAAC;IACH,CAAC,CAAA;IAED,OAAO,MAAM,CAAA;AACf,CAAC,CAAA;AAjCY,QAAA,SAAS,aAiCrB;AAED,uCAAuC;AAChC,MAAM,aAAa,GAAG,CAAI,EAAuB,EAAE,EAAE;IAC1D,MAAM,MAAM,GAAG,CAAC,IAAY,EAAE,GAAkB,EAAE,EAAE;QAClD,MAAM,GAAG,GAAG,GAAG,CAAC,UAAU,IAAI,kBAAU,CAAA;QACxC,IAAI,OAAO,GAAG,CAAC,CAAA;QACf,OAAO,IAAI,EAAE,CAAC;YACZ,IAAI,CAAC;gBACH,OAAO,EAAE,CAAC,IAAI,CAAC,CAAA;YACjB,CAAC;YAAC,OAAO,EAAE,EAAE,CAAC;gBACZ,IACE,IAAA,oBAAS,EAAC,EAAE,CAAC;oBACb,EAAE,CAAC,IAAI,KAAK,IAAI;oBAChB,aAAK,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC;oBAClB,OAAO,GAAG,GAAG,EACb,CAAC;oBACD,OAAO,EAAE,CAAA;oBACT,SAAQ;gBACV,CAAC;gBACD,MAAM,EAAE,CAAA;YACV,CAAC;QACH,CAAC;IACH,CAAC,CAAA;IACD,OAAO,MAAM,CAAA;AACf,CAAC,CAAA;AAtBY,QAAA,aAAa,iBAsBzB","sourcesContent":["// note: max backoff is the maximum that any *single* backoff will do\n\nimport { setTimeout } from 'timers/promises'\nimport { RimrafAsyncOptions, RimrafOptions } from './index.js'\nimport { isFsError } from './error.js'\n\nexport const MAXBACKOFF = 200\nexport const RATE = 1.2\nexport const MAXRETRIES = 10\nexport const codes = new Set(['EMFILE', 'ENFILE', 'EBUSY'])\n\nexport const retryBusy = <T>(fn: (path: string) => Promise<T>) => {\n  const method = async (\n    path: string,\n    opt: RimrafAsyncOptions,\n    backoff = 1,\n    total = 0,\n  ) => {\n    const mbo = opt.maxBackoff || MAXBACKOFF\n    const rate = opt.backoff || RATE\n    const max = opt.maxRetries || MAXRETRIES\n    let retries = 0\n    while (true) {\n      try {\n        return await fn(path)\n      } catch (er) {\n        if (isFsError(er) && er.path === path && codes.has(er.code)) {\n          backoff = Math.ceil(backoff * rate)\n          total = backoff + total\n          if (total < mbo) {\n            await setTimeout(backoff)\n            return method(path, opt, backoff, total)\n          }\n          if (retries < max) {\n            retries++\n            continue\n          }\n        }\n        throw er\n      }\n    }\n  }\n\n  return method\n}\n\n// just retries, no async so no backoff\nexport const retryBusySync = <T>(fn: (path: string) => T) => {\n  const method = (path: string, opt: RimrafOptions) => {\n    const max = opt.maxRetries || MAXRETRIES\n    let retries = 0\n    while (true) {\n      try {\n        return fn(path)\n      } catch (er) {\n        if (\n          isFsError(er) &&\n          er.path === path &&\n          codes.has(er.code) &&\n          retries < max\n        ) {\n          retries++\n          continue\n        }\n        throw er\n      }\n    }\n  }\n  return method\n}\n"]}